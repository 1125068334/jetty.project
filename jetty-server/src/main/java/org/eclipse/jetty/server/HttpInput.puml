@startuml
title "HttpInput"

participant HttpChannel as "Http\nChannel\n"
participant HttpChannelState as "Http\nChannel\nState"
participant Semaphore as "\nSemaphore\n"
participant ContentProducer as "Content\nProducer\n"
participant HttpInput as "Http\nInput\n"
participant Application as "\nApplication\n"

autoactivate on

== Blocking Read ==

Application->HttpInput: read
activate Application
HttpInput->ContentProducer: nextNon\nNullContent\n(BLOCK)
    loop for non null content
        ContentProducer->ContentProducer: nextContent(BLOCK)
            loop
                ContentProducer->HttpChannel: produceContent
                return
                alt content
                else content==null
                    ContentProducer->HttpChannelState: blockForContent
                        note over HttpChannelState
                        IDLE->BLOCKING
                        end note
                        HttpChannelState->HttpChannel: needContent
                        return
                        alt needContent
                        else true
                            note over HttpChannelState
                            BLOCKING->IDLE
                            end note
                            autoactivate off
                            HttpChannelState-->ContentProducer
                            autoactivate on
                            ...
                        else false
                            HttpChannelState->Semaphore: acquire
                            ... waiting for input ...
HttpChannel->HttpChannelState: onProducable
    activate HttpChannel
    note over HttpChannelState
    BLOCKING->IDLE
    end note
    HttpChannelState->Semaphore:release
    return
return
deactivate HttpChannel
                            return
                        return
                        ...
                    end
                    ...
                else content!=null
                return rawContent
                |||
            end
        end
            ContentProducer->ContentProducer: transform
            return
        alt if content
            return content
        end
    end
return content.read
deactivate Application
|||
...

newpage
== Available ==

Application->HttpInput: available
activate Application
HttpInput->ContentProducer: nextNon\nNullContent\n(POLL)
    loop for non null content
        ContentProducer->ContentProducer: nextContent(POLL)
            loop
                ContentProducer->HttpChannel: produceContent
                return

                note over ContentProducer
                break loop
                end note
            end
        return rawContent or null
        alt if rawContent!=null
            ContentProducer->ContentProducer: transform
            return
            |||
            alt if content
                return content
            end
        end
    end
return content.read
deactivate Application
|||
...

newpage

== Async Read ==


[->HttpChannel: handle
    loop
        HttpChannel->HttpChannelState: nextAction
        alt inputState
        else READY
            note over HttpChannelState
                READY->IDLE
            end note
            return ASYNC_READ
            ...
        end
        alt action
        else ASYNC_READ
            HttpChannel->HttpInput:isReady
                note over HttpInput
                    see below
                end note
            return
            alt isReady
            else true
                HttpChannel->Application:onDataAvailable
                    note left of Application
                    calls to isReady and read
                    may be made in this scope or by
                    other threads at any time.
                    see below.
                    end note
                return
            end
        end
    end
return
|||


Application->HttpInput: isReady
activate Application
HttpInput->ContentProducer: nextNon\nNullContent\n(ASYNC)
    loop for non null content
        ContentProducer->ContentProducer: nextContent(ASYNC)
            loop
                ContentProducer->HttpChannel: produceContent
                return
                alt content==null
                    ContentProducer->HttpChannelState: isReady
                        note over HttpChannelState
                        IDLE->UNREADY
                        end note
                        HttpChannelState->HttpChannel: needContent
                        return
                        alt needContent
                        else true
                            note over HttpChannelState
                            UNREADY->IDLE
                            end note
                            autoactivate off
                            HttpChannelState-->ContentProducer: true
                            autoactivate on
                            note over ContentProducer
                            continue loop
                            end note
                            ...
                        else false
                            return false
                        end
                end

            note over ContentProducer
            break loop
            end note
        end


        return rawContent or null
        alt if rawContent!=null
            ContentProducer->ContentProducer: transform
            return
            |||
        end

        return content!=null
    end
return content!=null
deactivate Application
|||
...

alt if content arrives
    note right of HttpChannel
        this may happen during isReady above or after.
        The full state handling is shown below, even for
        blocking cases
    end note
        HttpChannel->HttpChannelState: onProducable
            alt inputState
            else BLOCKING
                note over HttpChannelState
                BLOCKING->IDLE
                woken=false
                end note
                HttpChannelState->Semaphore:release
                return
                ...
            else UNREADY
                note over HttpChannelState
                UNREADY->READY
                woken=WAITING
                end note
                ...
            end
        return woken
        ...
end


Application->HttpInput: read
activate Application
    HttpInput->ContentProducer: read
        return content==null\n?ISE\n:content.read
    return
deactivate Application

|||

@enduml
